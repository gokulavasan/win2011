The design implements a chat room server with the optional 'ALL' chat room. The major key points are as follows.

i. addMessage and recentMessages methods were added to the ChatState class. 
ii. ThreadPool of 8 worker threads were implemented.
iii. ALL chat room functionality was implemented
iv. Synchronization was done at multiple places in the design depending on request type.

The design points are explained as follows.

i. addMessage - Synchronized to the history linked list object.  Checks whether the history linkedlist in the chatroom is of max size - if not adds the message (also increments the message ID) and if it is full removes the last message (and then adds).  NotifyAll called to release any pending/waiting recentMessage Calls.

recentMessages - Synchronized to the history linked list object.  wait(TIMEOUT) method is used to wait over the History linkedlist for 15 seconds if the ID is greater than the last seen ID, otherwise returns the messages with the ID numbers concatenated with new line characters as required.

ii. ThreadPool - WorkerThread class is created to work on the job added to the job list. It implements the handle method in the starter code. The runforever method adds new job to the JobQueue with the Socket Connection (ChatMessage class object has a member of type Socket). WorkInit function starts 8 worker threads. The workerThread synchronizes over JobQueue to remove a job from the linkedlist. Then it does the job of the handle method in the started code.

iii. "ALL" chat room - "ALL" chat room is added as a separate room in the HashMap. The workerThread recognizes that the request goes to a ALL chat room in which case - if it is a Push, the message is added to all rooms using a HashMap Iterator - if it is a pull, the messages are retrieved from the ALL chat room. In the case of push to ordinary chat room, the message is added to both the original chatroom and the ALL chat room.

iv. Synchronization - The key structures that needed to be synchronized were:
  a) ThreadPool (ChatServer) - Every thread needs to gain ownership of this structure to query the worklist for pending work.  If no pending work exists, the thread blocks on the structure.  The runForever main method also synchronizes on the worklist to add requests to it, notifying blocked threads when something comes in.
  
  b) StateByName (ChatServer) - All threads process requests and need to check rooms.  When a room does not exist, the threads add to the hash. This process needs to be synchronized on StateByName.  Key difference between reads and writes.  
       Reads only need to synchronize the query and add room functionality. They do not need to block other threads on calls to recentMessage as this is handled in ChatState.
       Writes need to hold the StateByName lock for either inserting to every existing room if directed at 'ALL', or the room and 'ALL' if targeting a specific room.
  
  c) History (ChatState) - addMessage and recentMessages need to synchronize access to this data structure.  The process has been described in section (i)